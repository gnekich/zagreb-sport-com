"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String

  _gt: String

  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String

  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String

  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String

  _lt: String

  _lte: String

  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String

  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

type __Directive {
  args: __InputValue

  description: String!

  isRepeatable: String!

  locations: String!

  name: String!
}

type __EnumValue {
  deprecationReason: String!

  description: String!

  isDeprecated: String!

  name: String!
}

type __Field {
  args: __InputValue

  deprecationReason: String!

  description: String!

  isDeprecated: String!

  name: String!

  type: __Type
}

type __InputValue {
  defaultValue: String!

  description: String!

  name: String!

  type: __Type
}

type __Schema {
  description: String!

  directives: __Directive

  mutationType: __Type

  queryType: __Type

  subscriptionType: __Type

  types: __Type
}

type __Type {
  description: String!

  enumValues(includeDeprecated: Boolean = false): __EnumValue

  fields(includeDeprecated: Boolean = false): __Field

  inputFields: __InputValue

  interfaces: __Type

  kind: __TypeKind!

  name: String!

  ofType: __Type

  possibleTypes: __Type
}

enum __TypeKind {
  ENUM

  INPUT_OBJECT

  INTERFACE

  LIST

  NON_NULL

  OBJECT

  SCALAR

  UNION
}

"""
ordering argument of a cursor
"""
enum cursor_ordering {
  """
  ascending ordering of the cursor
  """
  ASC

  """
  descending ordering of the cursor
  """
  DESC
}

"""
columns and relationships of "dogadjaj"
"""
type dogadjaj {
  address: String

  do: timestamptz

  id: uuid!

  long_lat: String

  name: String

  od: timestamptz

  publish_type: String

  slika_url: String
}

"""
aggregated selection of "dogadjaj"
"""
type dogadjaj_aggregate {
  aggregate: dogadjaj_aggregate_fields

  nodes: [dogadjaj!]!
}

"""
aggregate fields of "dogadjaj"
"""
type dogadjaj_aggregate_fields {
  count(columns: [dogadjaj_select_column!], distinct: Boolean): Int!

  max: dogadjaj_max_fields

  min: dogadjaj_min_fields
}

"""
Boolean expression to filter rows from the table "dogadjaj". All fields are combined with a logical 'AND'.
"""
input dogadjaj_bool_exp {
  _and: [dogadjaj_bool_exp!]

  _not: dogadjaj_bool_exp

  _or: [dogadjaj_bool_exp!]

  address: String_comparison_exp

  do: timestamptz_comparison_exp

  id: uuid_comparison_exp

  long_lat: String_comparison_exp

  name: String_comparison_exp

  od: timestamptz_comparison_exp

  publish_type: String_comparison_exp

  slika_url: String_comparison_exp
}

"""
unique or primary key constraints on table "dogadjaj"
"""
enum dogadjaj_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  dogadjaj_pkey
}

"""
input type for inserting data into table "dogadjaj"
"""
input dogadjaj_insert_input {
  address: String

  do: timestamptz

  id: uuid

  long_lat: String

  name: String

  od: timestamptz

  publish_type: String

  slika_url: String
}

"""
aggregate max on columns
"""
type dogadjaj_max_fields {
  address: String

  do: timestamptz

  id: uuid

  long_lat: String

  name: String

  od: timestamptz

  publish_type: String

  slika_url: String
}

"""
aggregate min on columns
"""
type dogadjaj_min_fields {
  address: String

  do: timestamptz

  id: uuid

  long_lat: String

  name: String

  od: timestamptz

  publish_type: String

  slika_url: String
}

"""
response of any mutation on the table "dogadjaj"
"""
type dogadjaj_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [dogadjaj!]!
}

"""
on_conflict condition type for table "dogadjaj"
"""
input dogadjaj_on_conflict {
  constraint: dogadjaj_constraint!

  update_columns: [dogadjaj_update_column!]! = []

  where: dogadjaj_bool_exp
}

"""
Ordering options when selecting data from "dogadjaj".
"""
input dogadjaj_order_by {
  address: order_by

  do: order_by

  id: order_by

  long_lat: order_by

  name: order_by

  od: order_by

  publish_type: order_by

  slika_url: order_by
}

"""
primary key columns input for table: dogadjaj
"""
input dogadjaj_pk_columns_input {
  id: uuid!
}

"""
select columns of table "dogadjaj"
"""
enum dogadjaj_select_column {
  """
  column name
  """
  address

  """
  column name
  """
  do

  """
  column name
  """
  id

  """
  column name
  """
  long_lat

  """
  column name
  """
  name

  """
  column name
  """
  od

  """
  column name
  """
  publish_type

  """
  column name
  """
  slika_url
}

"""
input type for updating data in table "dogadjaj"
"""
input dogadjaj_set_input {
  address: String

  do: timestamptz

  id: uuid

  long_lat: String

  name: String

  od: timestamptz

  publish_type: String

  slika_url: String
}

"""
Streaming cursor of the table "dogadjaj"
"""
input dogadjaj_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: dogadjaj_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input dogadjaj_stream_cursor_value_input {
  address: String

  do: timestamptz

  id: uuid

  long_lat: String

  name: String

  od: timestamptz

  publish_type: String

  slika_url: String
}

"""
update columns of table "dogadjaj"
"""
enum dogadjaj_update_column {
  """
  column name
  """
  address

  """
  column name
  """
  do

  """
  column name
  """
  id

  """
  column name
  """
  long_lat

  """
  column name
  """
  name

  """
  column name
  """
  od

  """
  column name
  """
  publish_type

  """
  column name
  """
  slika_url
}

input dogadjaj_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: dogadjaj_set_input

  """
  filter the rows which have to be updated
  """
  where: dogadjaj_bool_exp!
}

"""
columns and relationships of "dokumenti_saveza"
"""
type dokumenti_saveza {
  dokument_url: String

  id: uuid!

  naziv: String

  opis: String

  savez_id: uuid

  tip_dokumenta: String
}

"""
aggregated selection of "dokumenti_saveza"
"""
type dokumenti_saveza_aggregate {
  aggregate: dokumenti_saveza_aggregate_fields

  nodes: [dokumenti_saveza!]!
}

"""
aggregate fields of "dokumenti_saveza"
"""
type dokumenti_saveza_aggregate_fields {
  count(columns: [dokumenti_saveza_select_column!], distinct: Boolean): Int!

  max: dokumenti_saveza_max_fields

  min: dokumenti_saveza_min_fields
}

"""
Boolean expression to filter rows from the table "dokumenti_saveza". All fields are combined with a logical 'AND'.
"""
input dokumenti_saveza_bool_exp {
  _and: [dokumenti_saveza_bool_exp!]

  _not: dokumenti_saveza_bool_exp

  _or: [dokumenti_saveza_bool_exp!]

  dokument_url: String_comparison_exp

  id: uuid_comparison_exp

  naziv: String_comparison_exp

  opis: String_comparison_exp

  savez_id: uuid_comparison_exp

  tip_dokumenta: String_comparison_exp
}

"""
unique or primary key constraints on table "dokumenti_saveza"
"""
enum dokumenti_saveza_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  dokumenti_saveza_pkey
}

"""
input type for inserting data into table "dokumenti_saveza"
"""
input dokumenti_saveza_insert_input {
  dokument_url: String

  id: uuid

  naziv: String

  opis: String

  savez_id: uuid

  tip_dokumenta: String
}

"""
aggregate max on columns
"""
type dokumenti_saveza_max_fields {
  dokument_url: String

  id: uuid

  naziv: String

  opis: String

  savez_id: uuid

  tip_dokumenta: String
}

"""
aggregate min on columns
"""
type dokumenti_saveza_min_fields {
  dokument_url: String

  id: uuid

  naziv: String

  opis: String

  savez_id: uuid

  tip_dokumenta: String
}

"""
response of any mutation on the table "dokumenti_saveza"
"""
type dokumenti_saveza_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [dokumenti_saveza!]!
}

"""
on_conflict condition type for table "dokumenti_saveza"
"""
input dokumenti_saveza_on_conflict {
  constraint: dokumenti_saveza_constraint!

  update_columns: [dokumenti_saveza_update_column!]! = []

  where: dokumenti_saveza_bool_exp
}

"""
Ordering options when selecting data from "dokumenti_saveza".
"""
input dokumenti_saveza_order_by {
  dokument_url: order_by

  id: order_by

  naziv: order_by

  opis: order_by

  savez_id: order_by

  tip_dokumenta: order_by
}

"""
primary key columns input for table: dokumenti_saveza
"""
input dokumenti_saveza_pk_columns_input {
  id: uuid!
}

"""
select columns of table "dokumenti_saveza"
"""
enum dokumenti_saveza_select_column {
  """
  column name
  """
  dokument_url

  """
  column name
  """
  id

  """
  column name
  """
  naziv

  """
  column name
  """
  opis

  """
  column name
  """
  savez_id

  """
  column name
  """
  tip_dokumenta
}

"""
input type for updating data in table "dokumenti_saveza"
"""
input dokumenti_saveza_set_input {
  dokument_url: String

  id: uuid

  naziv: String

  opis: String

  savez_id: uuid

  tip_dokumenta: String
}

"""
Streaming cursor of the table "dokumenti_saveza"
"""
input dokumenti_saveza_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: dokumenti_saveza_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input dokumenti_saveza_stream_cursor_value_input {
  dokument_url: String

  id: uuid

  naziv: String

  opis: String

  savez_id: uuid

  tip_dokumenta: String
}

"""
update columns of table "dokumenti_saveza"
"""
enum dokumenti_saveza_update_column {
  """
  column name
  """
  dokument_url

  """
  column name
  """
  id

  """
  column name
  """
  naziv

  """
  column name
  """
  opis

  """
  column name
  """
  savez_id

  """
  column name
  """
  tip_dokumenta
}

input dokumenti_saveza_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: dokumenti_saveza_set_input

  """
  filter the rows which have to be updated
  """
  where: dokumenti_saveza_bool_exp!
}

"""
columns and relationships of "feed"
"""
type feed {
  created_at: timestamptz

  description: String

  id: uuid!

  meta_fields("JSON select path" path: String): json

  savez_id: uuid

  slika_url: String

  subject: String

  updated_at: timestamptz
}

"""
aggregated selection of "feed"
"""
type feed_aggregate {
  aggregate: feed_aggregate_fields

  nodes: [feed!]!
}

"""
aggregate fields of "feed"
"""
type feed_aggregate_fields {
  count(columns: [feed_select_column!], distinct: Boolean): Int!

  max: feed_max_fields

  min: feed_min_fields
}

"""
Boolean expression to filter rows from the table "feed". All fields are combined with a logical 'AND'.
"""
input feed_bool_exp {
  _and: [feed_bool_exp!]

  _not: feed_bool_exp

  _or: [feed_bool_exp!]

  created_at: timestamptz_comparison_exp

  description: String_comparison_exp

  id: uuid_comparison_exp

  meta_fields: json_comparison_exp

  savez_id: uuid_comparison_exp

  slika_url: String_comparison_exp

  subject: String_comparison_exp

  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "feed"
"""
enum feed_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  feed_pkey
}

"""
input type for inserting data into table "feed"
"""
input feed_insert_input {
  created_at: timestamptz

  description: String

  id: uuid

  meta_fields: json

  savez_id: uuid

  slika_url: String

  subject: String

  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type feed_max_fields {
  created_at: timestamptz

  description: String

  id: uuid

  savez_id: uuid

  slika_url: String

  subject: String

  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type feed_min_fields {
  created_at: timestamptz

  description: String

  id: uuid

  savez_id: uuid

  slika_url: String

  subject: String

  updated_at: timestamptz
}

"""
response of any mutation on the table "feed"
"""
type feed_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [feed!]!
}

"""
on_conflict condition type for table "feed"
"""
input feed_on_conflict {
  constraint: feed_constraint!

  update_columns: [feed_update_column!]! = []

  where: feed_bool_exp
}

"""
Ordering options when selecting data from "feed".
"""
input feed_order_by {
  created_at: order_by

  description: order_by

  id: order_by

  meta_fields: order_by

  savez_id: order_by

  slika_url: order_by

  subject: order_by

  updated_at: order_by
}

"""
primary key columns input for table: feed
"""
input feed_pk_columns_input {
  id: uuid!
}

"""
select columns of table "feed"
"""
enum feed_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  description

  """
  column name
  """
  id

  """
  column name
  """
  meta_fields

  """
  column name
  """
  savez_id

  """
  column name
  """
  slika_url

  """
  column name
  """
  subject

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "feed"
"""
input feed_set_input {
  created_at: timestamptz

  description: String

  id: uuid

  meta_fields: json

  savez_id: uuid

  slika_url: String

  subject: String

  updated_at: timestamptz
}

"""
Streaming cursor of the table "feed"
"""
input feed_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: feed_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input feed_stream_cursor_value_input {
  created_at: timestamptz

  description: String

  id: uuid

  meta_fields: json

  savez_id: uuid

  slika_url: String

  subject: String

  updated_at: timestamptz
}

"""
update columns of table "feed"
"""
enum feed_update_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  description

  """
  column name
  """
  id

  """
  column name
  """
  meta_fields

  """
  column name
  """
  savez_id

  """
  column name
  """
  slika_url

  """
  column name
  """
  subject

  """
  column name
  """
  updated_at
}

input feed_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: feed_set_input

  """
  filter the rows which have to be updated
  """
  where: feed_bool_exp!
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json

  _gt: json

  _gte: json

  _in: [json!]

  _is_null: Boolean

  _lt: json

  _lte: json

  _neq: json

  _nin: [json!]
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "dogadjaj"
  """
  delete_dogadjaj("filter the rows which have to be deleted" where: dogadjaj_bool_exp!): dogadjaj_mutation_response

  """
  delete single row from the table: "dogadjaj"
  """
  delete_dogadjaj_by_pk(id: uuid!): dogadjaj

  """
  delete data from the table: "dokumenti_saveza"
  """
  delete_dokumenti_saveza("filter the rows which have to be deleted" where: dokumenti_saveza_bool_exp!): dokumenti_saveza_mutation_response

  """
  delete single row from the table: "dokumenti_saveza"
  """
  delete_dokumenti_saveza_by_pk(id: uuid!): dokumenti_saveza

  """
  delete data from the table: "feed"
  """
  delete_feed("filter the rows which have to be deleted" where: feed_bool_exp!): feed_mutation_response

  """
  delete single row from the table: "feed"
  """
  delete_feed_by_pk(id: uuid!): feed

  """
  delete data from the table: "natjecatelji"
  """
  delete_natjecatelji("filter the rows which have to be deleted" where: natjecatelji_bool_exp!): natjecatelji_mutation_response

  """
  delete single row from the table: "natjecatelji"
  """
  delete_natjecatelji_by_pk(id: uuid!): natjecatelji

  """
  delete data from the table: "rezultati"
  """
  delete_rezultati("filter the rows which have to be deleted" where: rezultati_bool_exp!): rezultati_mutation_response

  """
  delete single row from the table: "rezultati"
  """
  delete_rezultati_by_pk(id: uuid!): rezultati

  """
  delete data from the table: "savezi"
  """
  delete_savezi("filter the rows which have to be deleted" where: savezi_bool_exp!): savezi_mutation_response

  """
  delete single row from the table: "savezi"
  """
  delete_savezi_by_pk(id: uuid!): savezi

  """
  delete data from the table: "sports"
  """
  delete_sports("filter the rows which have to be deleted" where: sports_bool_exp!): sports_mutation_response

  """
  delete single row from the table: "sports"
  """
  delete_sports_by_pk(id: uuid!): sports

  """
  delete data from the table: "users"
  """
  delete_users("filter the rows which have to be deleted" where: users_bool_exp!): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: uuid!): users

  """
  delete data from the table: "users_savez_access"
  """
  delete_users_savez_access("filter the rows which have to be deleted" where: users_savez_access_bool_exp!): users_savez_access_mutation_response

  """
  delete single row from the table: "users_savez_access"
  """
  delete_users_savez_access_by_pk(id: uuid!): users_savez_access

  """
  insert data into the table: "dogadjaj"
  """
  insert_dogadjaj("the rows to be inserted" objects: [dogadjaj_insert_input!]!, "upsert condition" on_conflict: dogadjaj_on_conflict): dogadjaj_mutation_response

  """
  insert a single row into the table: "dogadjaj"
  """
  insert_dogadjaj_one("the row to be inserted" object: dogadjaj_insert_input!, "upsert condition" on_conflict: dogadjaj_on_conflict): dogadjaj

  """
  insert data into the table: "dokumenti_saveza"
  """
  insert_dokumenti_saveza("the rows to be inserted" objects: [dokumenti_saveza_insert_input!]!, "upsert condition" on_conflict: dokumenti_saveza_on_conflict): dokumenti_saveza_mutation_response

  """
  insert a single row into the table: "dokumenti_saveza"
  """
  insert_dokumenti_saveza_one("the row to be inserted" object: dokumenti_saveza_insert_input!, "upsert condition" on_conflict: dokumenti_saveza_on_conflict): dokumenti_saveza

  """
  insert data into the table: "feed"
  """
  insert_feed("the rows to be inserted" objects: [feed_insert_input!]!, "upsert condition" on_conflict: feed_on_conflict): feed_mutation_response

  """
  insert a single row into the table: "feed"
  """
  insert_feed_one("the row to be inserted" object: feed_insert_input!, "upsert condition" on_conflict: feed_on_conflict): feed

  """
  insert data into the table: "natjecatelji"
  """
  insert_natjecatelji("the rows to be inserted" objects: [natjecatelji_insert_input!]!, "upsert condition" on_conflict: natjecatelji_on_conflict): natjecatelji_mutation_response

  """
  insert a single row into the table: "natjecatelji"
  """
  insert_natjecatelji_one("the row to be inserted" object: natjecatelji_insert_input!, "upsert condition" on_conflict: natjecatelji_on_conflict): natjecatelji

  """
  insert data into the table: "rezultati"
  """
  insert_rezultati("the rows to be inserted" objects: [rezultati_insert_input!]!, "upsert condition" on_conflict: rezultati_on_conflict): rezultati_mutation_response

  """
  insert a single row into the table: "rezultati"
  """
  insert_rezultati_one("the row to be inserted" object: rezultati_insert_input!, "upsert condition" on_conflict: rezultati_on_conflict): rezultati

  """
  insert data into the table: "savezi"
  """
  insert_savezi("the rows to be inserted" objects: [savezi_insert_input!]!, "upsert condition" on_conflict: savezi_on_conflict): savezi_mutation_response

  """
  insert a single row into the table: "savezi"
  """
  insert_savezi_one("the row to be inserted" object: savezi_insert_input!, "upsert condition" on_conflict: savezi_on_conflict): savezi

  """
  insert data into the table: "sports"
  """
  insert_sports("the rows to be inserted" objects: [sports_insert_input!]!, "upsert condition" on_conflict: sports_on_conflict): sports_mutation_response

  """
  insert a single row into the table: "sports"
  """
  insert_sports_one("the row to be inserted" object: sports_insert_input!, "upsert condition" on_conflict: sports_on_conflict): sports

  """
  insert data into the table: "users"
  """
  insert_users("the rows to be inserted" objects: [users_insert_input!]!, "upsert condition" on_conflict: users_on_conflict): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one("the row to be inserted" object: users_insert_input!, "upsert condition" on_conflict: users_on_conflict): users

  """
  insert data into the table: "users_savez_access"
  """
  insert_users_savez_access("the rows to be inserted" objects: [users_savez_access_insert_input!]!, "upsert condition" on_conflict: users_savez_access_on_conflict): users_savez_access_mutation_response

  """
  insert a single row into the table: "users_savez_access"
  """
  insert_users_savez_access_one("the row to be inserted" object: users_savez_access_insert_input!, "upsert condition" on_conflict: users_savez_access_on_conflict): users_savez_access

  """
  update data of the table: "dogadjaj"
  """
  update_dogadjaj("sets the columns of the filtered rows to the given values" _set: dogadjaj_set_input, "filter the rows which have to be updated" where: dogadjaj_bool_exp!): dogadjaj_mutation_response

  """
  update single row of the table: "dogadjaj"
  """
  update_dogadjaj_by_pk("sets the columns of the filtered rows to the given values" _set: dogadjaj_set_input, pk_columns: dogadjaj_pk_columns_input!): dogadjaj

  """
  update multiples rows of table: "dogadjaj"
  """
  update_dogadjaj_many("updates to execute, in order" updates: [dogadjaj_updates!]!): [dogadjaj_mutation_response]

  """
  update data of the table: "dokumenti_saveza"
  """
  update_dokumenti_saveza("sets the columns of the filtered rows to the given values" _set: dokumenti_saveza_set_input, "filter the rows which have to be updated" where: dokumenti_saveza_bool_exp!): dokumenti_saveza_mutation_response

  """
  update single row of the table: "dokumenti_saveza"
  """
  update_dokumenti_saveza_by_pk("sets the columns of the filtered rows to the given values" _set: dokumenti_saveza_set_input, pk_columns: dokumenti_saveza_pk_columns_input!): dokumenti_saveza

  """
  update multiples rows of table: "dokumenti_saveza"
  """
  update_dokumenti_saveza_many("updates to execute, in order" updates: [dokumenti_saveza_updates!]!): [dokumenti_saveza_mutation_response]

  """
  update data of the table: "feed"
  """
  update_feed("sets the columns of the filtered rows to the given values" _set: feed_set_input, "filter the rows which have to be updated" where: feed_bool_exp!): feed_mutation_response

  """
  update single row of the table: "feed"
  """
  update_feed_by_pk("sets the columns of the filtered rows to the given values" _set: feed_set_input, pk_columns: feed_pk_columns_input!): feed

  """
  update multiples rows of table: "feed"
  """
  update_feed_many("updates to execute, in order" updates: [feed_updates!]!): [feed_mutation_response]

  """
  update data of the table: "natjecatelji"
  """
  update_natjecatelji("sets the columns of the filtered rows to the given values" _set: natjecatelji_set_input, "filter the rows which have to be updated" where: natjecatelji_bool_exp!): natjecatelji_mutation_response

  """
  update single row of the table: "natjecatelji"
  """
  update_natjecatelji_by_pk("sets the columns of the filtered rows to the given values" _set: natjecatelji_set_input, pk_columns: natjecatelji_pk_columns_input!): natjecatelji

  """
  update multiples rows of table: "natjecatelji"
  """
  update_natjecatelji_many("updates to execute, in order" updates: [natjecatelji_updates!]!): [natjecatelji_mutation_response]

  """
  update data of the table: "rezultati"
  """
  update_rezultati("sets the columns of the filtered rows to the given values" _set: rezultati_set_input, "filter the rows which have to be updated" where: rezultati_bool_exp!): rezultati_mutation_response

  """
  update single row of the table: "rezultati"
  """
  update_rezultati_by_pk("sets the columns of the filtered rows to the given values" _set: rezultati_set_input, pk_columns: rezultati_pk_columns_input!): rezultati

  """
  update multiples rows of table: "rezultati"
  """
  update_rezultati_many("updates to execute, in order" updates: [rezultati_updates!]!): [rezultati_mutation_response]

  """
  update data of the table: "savezi"
  """
  update_savezi("sets the columns of the filtered rows to the given values" _set: savezi_set_input, "filter the rows which have to be updated" where: savezi_bool_exp!): savezi_mutation_response

  """
  update single row of the table: "savezi"
  """
  update_savezi_by_pk("sets the columns of the filtered rows to the given values" _set: savezi_set_input, pk_columns: savezi_pk_columns_input!): savezi

  """
  update multiples rows of table: "savezi"
  """
  update_savezi_many("updates to execute, in order" updates: [savezi_updates!]!): [savezi_mutation_response]

  """
  update data of the table: "sports"
  """
  update_sports("sets the columns of the filtered rows to the given values" _set: sports_set_input, "filter the rows which have to be updated" where: sports_bool_exp!): sports_mutation_response

  """
  update single row of the table: "sports"
  """
  update_sports_by_pk("sets the columns of the filtered rows to the given values" _set: sports_set_input, pk_columns: sports_pk_columns_input!): sports

  """
  update multiples rows of table: "sports"
  """
  update_sports_many("updates to execute, in order" updates: [sports_updates!]!): [sports_mutation_response]

  """
  update data of the table: "users"
  """
  update_users("sets the columns of the filtered rows to the given values" _set: users_set_input, "filter the rows which have to be updated" where: users_bool_exp!): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk("sets the columns of the filtered rows to the given values" _set: users_set_input, pk_columns: users_pk_columns_input!): users

  """
  update multiples rows of table: "users"
  """
  update_users_many("updates to execute, in order" updates: [users_updates!]!): [users_mutation_response]

  """
  update data of the table: "users_savez_access"
  """
  update_users_savez_access("sets the columns of the filtered rows to the given values" _set: users_savez_access_set_input, "filter the rows which have to be updated" where: users_savez_access_bool_exp!): users_savez_access_mutation_response

  """
  update single row of the table: "users_savez_access"
  """
  update_users_savez_access_by_pk("sets the columns of the filtered rows to the given values" _set: users_savez_access_set_input, pk_columns: users_savez_access_pk_columns_input!): users_savez_access

  """
  update multiples rows of table: "users_savez_access"
  """
  update_users_savez_access_many("updates to execute, in order" updates: [users_savez_access_updates!]!): [users_savez_access_mutation_response]
}

"""
columns and relationships of "natjecatelji"
"""
type natjecatelji {
  id: uuid!

  ime: String!

  prezime: String!
}

"""
aggregated selection of "natjecatelji"
"""
type natjecatelji_aggregate {
  aggregate: natjecatelji_aggregate_fields

  nodes: [natjecatelji!]!
}

"""
aggregate fields of "natjecatelji"
"""
type natjecatelji_aggregate_fields {
  count(columns: [natjecatelji_select_column!], distinct: Boolean): Int!

  max: natjecatelji_max_fields

  min: natjecatelji_min_fields
}

"""
Boolean expression to filter rows from the table "natjecatelji". All fields are combined with a logical 'AND'.
"""
input natjecatelji_bool_exp {
  _and: [natjecatelji_bool_exp!]

  _not: natjecatelji_bool_exp

  _or: [natjecatelji_bool_exp!]

  id: uuid_comparison_exp

  ime: String_comparison_exp

  prezime: String_comparison_exp
}

"""
unique or primary key constraints on table "natjecatelji"
"""
enum natjecatelji_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  natjecatelji_pkey
}

"""
input type for inserting data into table "natjecatelji"
"""
input natjecatelji_insert_input {
  id: uuid

  ime: String

  prezime: String
}

"""
aggregate max on columns
"""
type natjecatelji_max_fields {
  id: uuid

  ime: String

  prezime: String
}

"""
aggregate min on columns
"""
type natjecatelji_min_fields {
  id: uuid

  ime: String

  prezime: String
}

"""
response of any mutation on the table "natjecatelji"
"""
type natjecatelji_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [natjecatelji!]!
}

"""
on_conflict condition type for table "natjecatelji"
"""
input natjecatelji_on_conflict {
  constraint: natjecatelji_constraint!

  update_columns: [natjecatelji_update_column!]! = []

  where: natjecatelji_bool_exp
}

"""
Ordering options when selecting data from "natjecatelji".
"""
input natjecatelji_order_by {
  id: order_by

  ime: order_by

  prezime: order_by
}

"""
primary key columns input for table: natjecatelji
"""
input natjecatelji_pk_columns_input {
  id: uuid!
}

"""
select columns of table "natjecatelji"
"""
enum natjecatelji_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  ime

  """
  column name
  """
  prezime
}

"""
input type for updating data in table "natjecatelji"
"""
input natjecatelji_set_input {
  id: uuid

  ime: String

  prezime: String
}

"""
Streaming cursor of the table "natjecatelji"
"""
input natjecatelji_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: natjecatelji_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input natjecatelji_stream_cursor_value_input {
  id: uuid

  ime: String

  prezime: String
}

"""
update columns of table "natjecatelji"
"""
enum natjecatelji_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  ime

  """
  column name
  """
  prezime
}

input natjecatelji_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: natjecatelji_set_input

  """
  filter the rows which have to be updated
  """
  where: natjecatelji_bool_exp!
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "dogadjaj"
  """
  dogadjaj("distinct select on columns" distinct_on: [dogadjaj_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dogadjaj_order_by!], "filter the rows returned" where: dogadjaj_bool_exp): [dogadjaj!]!

  """
  fetch aggregated fields from the table: "dogadjaj"
  """
  dogadjaj_aggregate("distinct select on columns" distinct_on: [dogadjaj_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dogadjaj_order_by!], "filter the rows returned" where: dogadjaj_bool_exp): dogadjaj_aggregate!

  """
  fetch data from the table: "dogadjaj" using primary key columns
  """
  dogadjaj_by_pk(id: uuid!): dogadjaj

  """
  fetch data from the table: "dokumenti_saveza"
  """
  dokumenti_saveza("distinct select on columns" distinct_on: [dokumenti_saveza_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dokumenti_saveza_order_by!], "filter the rows returned" where: dokumenti_saveza_bool_exp): [dokumenti_saveza!]!

  """
  fetch aggregated fields from the table: "dokumenti_saveza"
  """
  dokumenti_saveza_aggregate("distinct select on columns" distinct_on: [dokumenti_saveza_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dokumenti_saveza_order_by!], "filter the rows returned" where: dokumenti_saveza_bool_exp): dokumenti_saveza_aggregate!

  """
  fetch data from the table: "dokumenti_saveza" using primary key columns
  """
  dokumenti_saveza_by_pk(id: uuid!): dokumenti_saveza

  """
  fetch data from the table: "feed"
  """
  feed("distinct select on columns" distinct_on: [feed_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [feed_order_by!], "filter the rows returned" where: feed_bool_exp): [feed!]!

  """
  fetch aggregated fields from the table: "feed"
  """
  feed_aggregate("distinct select on columns" distinct_on: [feed_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [feed_order_by!], "filter the rows returned" where: feed_bool_exp): feed_aggregate!

  """
  fetch data from the table: "feed" using primary key columns
  """
  feed_by_pk(id: uuid!): feed

  """
  fetch data from the table: "natjecatelji"
  """
  natjecatelji("distinct select on columns" distinct_on: [natjecatelji_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [natjecatelji_order_by!], "filter the rows returned" where: natjecatelji_bool_exp): [natjecatelji!]!

  """
  fetch aggregated fields from the table: "natjecatelji"
  """
  natjecatelji_aggregate("distinct select on columns" distinct_on: [natjecatelji_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [natjecatelji_order_by!], "filter the rows returned" where: natjecatelji_bool_exp): natjecatelji_aggregate!

  """
  fetch data from the table: "natjecatelji" using primary key columns
  """
  natjecatelji_by_pk(id: uuid!): natjecatelji

  """
  fetch data from the table: "rezultati"
  """
  rezultati("distinct select on columns" distinct_on: [rezultati_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [rezultati_order_by!], "filter the rows returned" where: rezultati_bool_exp): [rezultati!]!

  """
  fetch aggregated fields from the table: "rezultati"
  """
  rezultati_aggregate("distinct select on columns" distinct_on: [rezultati_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [rezultati_order_by!], "filter the rows returned" where: rezultati_bool_exp): rezultati_aggregate!

  """
  fetch data from the table: "rezultati" using primary key columns
  """
  rezultati_by_pk(id: uuid!): rezultati

  """
  fetch data from the table: "savezi"
  """
  savezi("distinct select on columns" distinct_on: [savezi_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [savezi_order_by!], "filter the rows returned" where: savezi_bool_exp): [savezi!]!

  """
  fetch aggregated fields from the table: "savezi"
  """
  savezi_aggregate("distinct select on columns" distinct_on: [savezi_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [savezi_order_by!], "filter the rows returned" where: savezi_bool_exp): savezi_aggregate!

  """
  fetch data from the table: "savezi" using primary key columns
  """
  savezi_by_pk(id: uuid!): savezi

  """
  fetch data from the table: "sports"
  """
  sports("distinct select on columns" distinct_on: [sports_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [sports_order_by!], "filter the rows returned" where: sports_bool_exp): [sports!]!

  """
  fetch aggregated fields from the table: "sports"
  """
  sports_aggregate("distinct select on columns" distinct_on: [sports_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [sports_order_by!], "filter the rows returned" where: sports_bool_exp): sports_aggregate!

  """
  fetch data from the table: "sports" using primary key columns
  """
  sports_by_pk(id: uuid!): sports

  """
  fetch data from the table: "users"
  """
  users("distinct select on columns" distinct_on: [users_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [users_order_by!], "filter the rows returned" where: users_bool_exp): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate("distinct select on columns" distinct_on: [users_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [users_order_by!], "filter the rows returned" where: users_bool_exp): users_aggregate!

  """
  fetch data from the table: "users" using primary key columns
  """
  users_by_pk(id: uuid!): users

  """
  fetch data from the table: "users_savez_access"
  """
  users_savez_access("distinct select on columns" distinct_on: [users_savez_access_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [users_savez_access_order_by!], "filter the rows returned" where: users_savez_access_bool_exp): [users_savez_access!]!

  """
  fetch aggregated fields from the table: "users_savez_access"
  """
  users_savez_access_aggregate("distinct select on columns" distinct_on: [users_savez_access_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [users_savez_access_order_by!], "filter the rows returned" where: users_savez_access_bool_exp): users_savez_access_aggregate!

  """
  fetch data from the table: "users_savez_access" using primary key columns
  """
  users_savez_access_by_pk(id: uuid!): users_savez_access
}

"""
columns and relationships of "rezultati"
"""
type rezultati {
  created_at: timestamptz

  id: uuid!

  payload("JSON select path" path: String): json

  savez_id: String

  updated_at: timestamptz
}

"""
aggregated selection of "rezultati"
"""
type rezultati_aggregate {
  aggregate: rezultati_aggregate_fields

  nodes: [rezultati!]!
}

"""
aggregate fields of "rezultati"
"""
type rezultati_aggregate_fields {
  count(columns: [rezultati_select_column!], distinct: Boolean): Int!

  max: rezultati_max_fields

  min: rezultati_min_fields
}

"""
Boolean expression to filter rows from the table "rezultati". All fields are combined with a logical 'AND'.
"""
input rezultati_bool_exp {
  _and: [rezultati_bool_exp!]

  _not: rezultati_bool_exp

  _or: [rezultati_bool_exp!]

  created_at: timestamptz_comparison_exp

  id: uuid_comparison_exp

  payload: json_comparison_exp

  savez_id: String_comparison_exp

  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "rezultati"
"""
enum rezultati_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  rezultati_pkey
}

"""
input type for inserting data into table "rezultati"
"""
input rezultati_insert_input {
  created_at: timestamptz

  id: uuid

  payload: json

  savez_id: String

  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type rezultati_max_fields {
  created_at: timestamptz

  id: uuid

  savez_id: String

  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type rezultati_min_fields {
  created_at: timestamptz

  id: uuid

  savez_id: String

  updated_at: timestamptz
}

"""
response of any mutation on the table "rezultati"
"""
type rezultati_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [rezultati!]!
}

"""
on_conflict condition type for table "rezultati"
"""
input rezultati_on_conflict {
  constraint: rezultati_constraint!

  update_columns: [rezultati_update_column!]! = []

  where: rezultati_bool_exp
}

"""
Ordering options when selecting data from "rezultati".
"""
input rezultati_order_by {
  created_at: order_by

  id: order_by

  payload: order_by

  savez_id: order_by

  updated_at: order_by
}

"""
primary key columns input for table: rezultati
"""
input rezultati_pk_columns_input {
  id: uuid!
}

"""
select columns of table "rezultati"
"""
enum rezultati_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  payload

  """
  column name
  """
  savez_id

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "rezultati"
"""
input rezultati_set_input {
  created_at: timestamptz

  id: uuid

  payload: json

  savez_id: String

  updated_at: timestamptz
}

"""
Streaming cursor of the table "rezultati"
"""
input rezultati_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: rezultati_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input rezultati_stream_cursor_value_input {
  created_at: timestamptz

  id: uuid

  payload: json

  savez_id: String

  updated_at: timestamptz
}

"""
update columns of table "rezultati"
"""
enum rezultati_update_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  payload

  """
  column name
  """
  savez_id

  """
  column name
  """
  updated_at
}

input rezultati_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: rezultati_set_input

  """
  filter the rows which have to be updated
  """
  where: rezultati_bool_exp!
}

"""
columns and relationships of "savezi"
"""
type savezi {
  id: uuid!

  kontakt_email: String

  name: String

  web_url: String
}

"""
aggregated selection of "savezi"
"""
type savezi_aggregate {
  aggregate: savezi_aggregate_fields

  nodes: [savezi!]!
}

"""
aggregate fields of "savezi"
"""
type savezi_aggregate_fields {
  count(columns: [savezi_select_column!], distinct: Boolean): Int!

  max: savezi_max_fields

  min: savezi_min_fields
}

"""
Boolean expression to filter rows from the table "savezi". All fields are combined with a logical 'AND'.
"""
input savezi_bool_exp {
  _and: [savezi_bool_exp!]

  _not: savezi_bool_exp

  _or: [savezi_bool_exp!]

  id: uuid_comparison_exp

  kontakt_email: String_comparison_exp

  name: String_comparison_exp

  web_url: String_comparison_exp
}

"""
unique or primary key constraints on table "savezi"
"""
enum savezi_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  savezi_pkey
}

"""
input type for inserting data into table "savezi"
"""
input savezi_insert_input {
  id: uuid

  kontakt_email: String

  name: String

  web_url: String
}

"""
aggregate max on columns
"""
type savezi_max_fields {
  id: uuid

  kontakt_email: String

  name: String

  web_url: String
}

"""
aggregate min on columns
"""
type savezi_min_fields {
  id: uuid

  kontakt_email: String

  name: String

  web_url: String
}

"""
response of any mutation on the table "savezi"
"""
type savezi_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [savezi!]!
}

"""
on_conflict condition type for table "savezi"
"""
input savezi_on_conflict {
  constraint: savezi_constraint!

  update_columns: [savezi_update_column!]! = []

  where: savezi_bool_exp
}

"""
Ordering options when selecting data from "savezi".
"""
input savezi_order_by {
  id: order_by

  kontakt_email: order_by

  name: order_by

  web_url: order_by
}

"""
primary key columns input for table: savezi
"""
input savezi_pk_columns_input {
  id: uuid!
}

"""
select columns of table "savezi"
"""
enum savezi_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  kontakt_email

  """
  column name
  """
  name

  """
  column name
  """
  web_url
}

"""
input type for updating data in table "savezi"
"""
input savezi_set_input {
  id: uuid

  kontakt_email: String

  name: String

  web_url: String
}

"""
Streaming cursor of the table "savezi"
"""
input savezi_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: savezi_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input savezi_stream_cursor_value_input {
  id: uuid

  kontakt_email: String

  name: String

  web_url: String
}

"""
update columns of table "savezi"
"""
enum savezi_update_column {
  """
  column name
  """
  id

  """
  column name
  """
  kontakt_email

  """
  column name
  """
  name

  """
  column name
  """
  web_url
}

input savezi_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: savezi_set_input

  """
  filter the rows which have to be updated
  """
  where: savezi_bool_exp!
}

"""
Table containing the list of sports
"""
type sports {
  created_at: timestamptz

  id: uuid!

  name: String

  updated_at: timestamptz
}

"""
aggregated selection of "sports"
"""
type sports_aggregate {
  aggregate: sports_aggregate_fields

  nodes: [sports!]!
}

"""
aggregate fields of "sports"
"""
type sports_aggregate_fields {
  count(columns: [sports_select_column!], distinct: Boolean): Int!

  max: sports_max_fields

  min: sports_min_fields
}

"""
Boolean expression to filter rows from the table "sports". All fields are combined with a logical 'AND'.
"""
input sports_bool_exp {
  _and: [sports_bool_exp!]

  _not: sports_bool_exp

  _or: [sports_bool_exp!]

  created_at: timestamptz_comparison_exp

  id: uuid_comparison_exp

  name: String_comparison_exp

  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "sports"
"""
enum sports_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sports_pkey
}

"""
input type for inserting data into table "sports"
"""
input sports_insert_input {
  created_at: timestamptz

  id: uuid

  name: String

  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type sports_max_fields {
  created_at: timestamptz

  id: uuid

  name: String

  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type sports_min_fields {
  created_at: timestamptz

  id: uuid

  name: String

  updated_at: timestamptz
}

"""
response of any mutation on the table "sports"
"""
type sports_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [sports!]!
}

"""
on_conflict condition type for table "sports"
"""
input sports_on_conflict {
  constraint: sports_constraint!

  update_columns: [sports_update_column!]! = []

  where: sports_bool_exp
}

"""
Ordering options when selecting data from "sports".
"""
input sports_order_by {
  created_at: order_by

  id: order_by

  name: order_by

  updated_at: order_by
}

"""
primary key columns input for table: sports
"""
input sports_pk_columns_input {
  id: uuid!
}

"""
select columns of table "sports"
"""
enum sports_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "sports"
"""
input sports_set_input {
  created_at: timestamptz

  id: uuid

  name: String

  updated_at: timestamptz
}

"""
Streaming cursor of the table "sports"
"""
input sports_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: sports_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input sports_stream_cursor_value_input {
  created_at: timestamptz

  id: uuid

  name: String

  updated_at: timestamptz
}

"""
update columns of table "sports"
"""
enum sports_update_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  updated_at
}

input sports_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: sports_set_input

  """
  filter the rows which have to be updated
  """
  where: sports_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "dogadjaj"
  """
  dogadjaj("distinct select on columns" distinct_on: [dogadjaj_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dogadjaj_order_by!], "filter the rows returned" where: dogadjaj_bool_exp): [dogadjaj!]!

  """
  fetch aggregated fields from the table: "dogadjaj"
  """
  dogadjaj_aggregate("distinct select on columns" distinct_on: [dogadjaj_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dogadjaj_order_by!], "filter the rows returned" where: dogadjaj_bool_exp): dogadjaj_aggregate!

  """
  fetch data from the table: "dogadjaj" using primary key columns
  """
  dogadjaj_by_pk(id: uuid!): dogadjaj

  """
  fetch data from the table in a streaming manner: "dogadjaj"
  """
  dogadjaj_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [dogadjaj_stream_cursor_input]!, "filter the rows returned" where: dogadjaj_bool_exp): [dogadjaj!]!

  """
  fetch data from the table: "dokumenti_saveza"
  """
  dokumenti_saveza("distinct select on columns" distinct_on: [dokumenti_saveza_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dokumenti_saveza_order_by!], "filter the rows returned" where: dokumenti_saveza_bool_exp): [dokumenti_saveza!]!

  """
  fetch aggregated fields from the table: "dokumenti_saveza"
  """
  dokumenti_saveza_aggregate("distinct select on columns" distinct_on: [dokumenti_saveza_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [dokumenti_saveza_order_by!], "filter the rows returned" where: dokumenti_saveza_bool_exp): dokumenti_saveza_aggregate!

  """
  fetch data from the table: "dokumenti_saveza" using primary key columns
  """
  dokumenti_saveza_by_pk(id: uuid!): dokumenti_saveza

  """
  fetch data from the table in a streaming manner: "dokumenti_saveza"
  """
  dokumenti_saveza_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [dokumenti_saveza_stream_cursor_input]!, "filter the rows returned" where: dokumenti_saveza_bool_exp): [dokumenti_saveza!]!

  """
  fetch data from the table: "feed"
  """
  feed("distinct select on columns" distinct_on: [feed_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [feed_order_by!], "filter the rows returned" where: feed_bool_exp): [feed!]!

  """
  fetch aggregated fields from the table: "feed"
  """
  feed_aggregate("distinct select on columns" distinct_on: [feed_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [feed_order_by!], "filter the rows returned" where: feed_bool_exp): feed_aggregate!

  """
  fetch data from the table: "feed" using primary key columns
  """
  feed_by_pk(id: uuid!): feed

  """
  fetch data from the table in a streaming manner: "feed"
  """
  feed_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [feed_stream_cursor_input]!, "filter the rows returned" where: feed_bool_exp): [feed!]!

  """
  fetch data from the table: "natjecatelji"
  """
  natjecatelji("distinct select on columns" distinct_on: [natjecatelji_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [natjecatelji_order_by!], "filter the rows returned" where: natjecatelji_bool_exp): [natjecatelji!]!

  """
  fetch aggregated fields from the table: "natjecatelji"
  """
  natjecatelji_aggregate("distinct select on columns" distinct_on: [natjecatelji_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [natjecatelji_order_by!], "filter the rows returned" where: natjecatelji_bool_exp): natjecatelji_aggregate!

  """
  fetch data from the table: "natjecatelji" using primary key columns
  """
  natjecatelji_by_pk(id: uuid!): natjecatelji

  """
  fetch data from the table in a streaming manner: "natjecatelji"
  """
  natjecatelji_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [natjecatelji_stream_cursor_input]!, "filter the rows returned" where: natjecatelji_bool_exp): [natjecatelji!]!

  """
  fetch data from the table: "rezultati"
  """
  rezultati("distinct select on columns" distinct_on: [rezultati_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [rezultati_order_by!], "filter the rows returned" where: rezultati_bool_exp): [rezultati!]!

  """
  fetch aggregated fields from the table: "rezultati"
  """
  rezultati_aggregate("distinct select on columns" distinct_on: [rezultati_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [rezultati_order_by!], "filter the rows returned" where: rezultati_bool_exp): rezultati_aggregate!

  """
  fetch data from the table: "rezultati" using primary key columns
  """
  rezultati_by_pk(id: uuid!): rezultati

  """
  fetch data from the table in a streaming manner: "rezultati"
  """
  rezultati_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [rezultati_stream_cursor_input]!, "filter the rows returned" where: rezultati_bool_exp): [rezultati!]!

  """
  fetch data from the table: "savezi"
  """
  savezi("distinct select on columns" distinct_on: [savezi_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [savezi_order_by!], "filter the rows returned" where: savezi_bool_exp): [savezi!]!

  """
  fetch aggregated fields from the table: "savezi"
  """
  savezi_aggregate("distinct select on columns" distinct_on: [savezi_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [savezi_order_by!], "filter the rows returned" where: savezi_bool_exp): savezi_aggregate!

  """
  fetch data from the table: "savezi" using primary key columns
  """
  savezi_by_pk(id: uuid!): savezi

  """
  fetch data from the table in a streaming manner: "savezi"
  """
  savezi_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [savezi_stream_cursor_input]!, "filter the rows returned" where: savezi_bool_exp): [savezi!]!

  """
  fetch data from the table: "sports"
  """
  sports("distinct select on columns" distinct_on: [sports_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [sports_order_by!], "filter the rows returned" where: sports_bool_exp): [sports!]!

  """
  fetch aggregated fields from the table: "sports"
  """
  sports_aggregate("distinct select on columns" distinct_on: [sports_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [sports_order_by!], "filter the rows returned" where: sports_bool_exp): sports_aggregate!

  """
  fetch data from the table: "sports" using primary key columns
  """
  sports_by_pk(id: uuid!): sports

  """
  fetch data from the table in a streaming manner: "sports"
  """
  sports_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [sports_stream_cursor_input]!, "filter the rows returned" where: sports_bool_exp): [sports!]!

  """
  fetch data from the table: "users"
  """
  users("distinct select on columns" distinct_on: [users_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [users_order_by!], "filter the rows returned" where: users_bool_exp): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate("distinct select on columns" distinct_on: [users_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [users_order_by!], "filter the rows returned" where: users_bool_exp): users_aggregate!

  """
  fetch data from the table: "users" using primary key columns
  """
  users_by_pk(id: uuid!): users

  """
  fetch data from the table: "users_savez_access"
  """
  users_savez_access("distinct select on columns" distinct_on: [users_savez_access_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [users_savez_access_order_by!], "filter the rows returned" where: users_savez_access_bool_exp): [users_savez_access!]!

  """
  fetch aggregated fields from the table: "users_savez_access"
  """
  users_savez_access_aggregate("distinct select on columns" distinct_on: [users_savez_access_select_column!], "limit the number of rows returned" limit: Int, "skip the first n rows. Use only with order_by" offset: Int, "sort the rows by one or more columns" order_by: [users_savez_access_order_by!], "filter the rows returned" where: users_savez_access_bool_exp): users_savez_access_aggregate!

  """
  fetch data from the table: "users_savez_access" using primary key columns
  """
  users_savez_access_by_pk(id: uuid!): users_savez_access

  """
  fetch data from the table in a streaming manner: "users_savez_access"
  """
  users_savez_access_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [users_savez_access_stream_cursor_input]!, "filter the rows returned" where: users_savez_access_bool_exp): [users_savez_access!]!

  """
  fetch data from the table in a streaming manner: "users"
  """
  users_stream("maximum number of rows returned in a single batch" batch_size: Int!, "cursor to stream the results returned by the query" cursor: [users_stream_cursor_input]!, "filter the rows returned" where: users_bool_exp): [users!]!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz

  _gt: timestamptz

  _gte: timestamptz

  _in: [timestamptz!]

  _is_null: Boolean

  _lt: timestamptz

  _lte: timestamptz

  _neq: timestamptz

  _nin: [timestamptz!]
}

"""
Users table
"""
type users {
  created_at: timestamptz!

  email: String

  id: uuid!

  updated_at: timestamptz!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields

  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!

  max: users_max_fields

  min: users_min_fields
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]

  _not: users_bool_exp

  _or: [users_bool_exp!]

  created_at: timestamptz_comparison_exp

  email: String_comparison_exp

  id: uuid_comparison_exp

  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  created_at: timestamptz

  email: String

  id: uuid

  updated_at: timestamptz
}

"""
aggregate max on columns
"""
type users_max_fields {
  created_at: timestamptz

  email: String

  id: uuid

  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type users_min_fields {
  created_at: timestamptz

  email: String

  id: uuid

  updated_at: timestamptz
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [users!]!
}

"""
on_conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!

  update_columns: [users_update_column!]! = []

  where: users_bool_exp
}

"""
Ordering options when selecting data from "users".
"""
input users_order_by {
  created_at: order_by

  email: order_by

  id: order_by

  updated_at: order_by
}

"""
primary key columns input for table: users
"""
input users_pk_columns_input {
  id: uuid!
}

"""
Table containing the list access types for a user
"""
type users_savez_access {
  access_role: String

  email: String!

  id: uuid!

  savez_id: uuid!
}

"""
aggregated selection of "users_savez_access"
"""
type users_savez_access_aggregate {
  aggregate: users_savez_access_aggregate_fields

  nodes: [users_savez_access!]!
}

"""
aggregate fields of "users_savez_access"
"""
type users_savez_access_aggregate_fields {
  count(columns: [users_savez_access_select_column!], distinct: Boolean): Int!

  max: users_savez_access_max_fields

  min: users_savez_access_min_fields
}

"""
Boolean expression to filter rows from the table "users_savez_access". All fields are combined with a logical 'AND'.
"""
input users_savez_access_bool_exp {
  _and: [users_savez_access_bool_exp!]

  _not: users_savez_access_bool_exp

  _or: [users_savez_access_bool_exp!]

  access_role: String_comparison_exp

  email: String_comparison_exp

  id: uuid_comparison_exp

  savez_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "users_savez_access"
"""
enum users_savez_access_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  users_savez_access_pkey
}

"""
input type for inserting data into table "users_savez_access"
"""
input users_savez_access_insert_input {
  access_role: String

  email: String

  id: uuid

  savez_id: uuid
}

"""
aggregate max on columns
"""
type users_savez_access_max_fields {
  access_role: String

  email: String

  id: uuid

  savez_id: uuid
}

"""
aggregate min on columns
"""
type users_savez_access_min_fields {
  access_role: String

  email: String

  id: uuid

  savez_id: uuid
}

"""
response of any mutation on the table "users_savez_access"
"""
type users_savez_access_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [users_savez_access!]!
}

"""
on_conflict condition type for table "users_savez_access"
"""
input users_savez_access_on_conflict {
  constraint: users_savez_access_constraint!

  update_columns: [users_savez_access_update_column!]! = []

  where: users_savez_access_bool_exp
}

"""
Ordering options when selecting data from "users_savez_access".
"""
input users_savez_access_order_by {
  access_role: order_by

  email: order_by

  id: order_by

  savez_id: order_by
}

"""
primary key columns input for table: users_savez_access
"""
input users_savez_access_pk_columns_input {
  id: uuid!
}

"""
select columns of table "users_savez_access"
"""
enum users_savez_access_select_column {
  """
  column name
  """
  access_role

  """
  column name
  """
  email

  """
  column name
  """
  id

  """
  column name
  """
  savez_id
}

"""
input type for updating data in table "users_savez_access"
"""
input users_savez_access_set_input {
  access_role: String

  email: String

  id: uuid

  savez_id: uuid
}

"""
Streaming cursor of the table "users_savez_access"
"""
input users_savez_access_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: users_savez_access_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input users_savez_access_stream_cursor_value_input {
  access_role: String

  email: String

  id: uuid

  savez_id: uuid
}

"""
update columns of table "users_savez_access"
"""
enum users_savez_access_update_column {
  """
  column name
  """
  access_role

  """
  column name
  """
  email

  """
  column name
  """
  id

  """
  column name
  """
  savez_id
}

input users_savez_access_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: users_savez_access_set_input

  """
  filter the rows which have to be updated
  """
  where: users_savez_access_bool_exp!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  email

  """
  column name
  """
  id

  """
  column name
  """
  updated_at
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  created_at: timestamptz

  email: String

  id: uuid

  updated_at: timestamptz
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: users_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input users_stream_cursor_value_input {
  created_at: timestamptz

  email: String

  id: uuid

  updated_at: timestamptz
}

"""
update columns of table "users"
"""
enum users_update_column {
  """
  column name
  """
  created_at

  """
  column name
  """
  email

  """
  column name
  """
  id

  """
  column name
  """
  updated_at
}

input users_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: users_set_input

  """
  filter the rows which have to be updated
  """
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid

  _gt: uuid

  _gte: uuid

  _in: [uuid!]

  _is_null: Boolean

  _lt: uuid

  _lte: uuid

  _neq: uuid

  _nin: [uuid!]
}

"""
whether this query should be included
"""
directive @include (if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

"""
whether this query should be skipped
"""
directive @skip (if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached ("measured in seconds" ttl: Int! = 60, "refresh the cache entry" refresh: Boolean! = false) on QUERY

schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}
